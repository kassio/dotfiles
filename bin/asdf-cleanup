#!/usr/bin/env ruby
# frozen_string_literal: true

require 'set'
require 'open3'

BASE_PATH = File.join(ENV['HOME'], 'src/**/*')

CommandResult = Struct.new(:output, :message, :status) do
  def success?
    status&.success?
  end
end

def asdf(*args)
  CommandResult.new(*Open3.capture3(*['asdf', args].flatten))
rescue StandardError => e
  CommandResult.new('', e.message, false)
end

def uniq_file_paths(glob)
  Dir.glob(File.join(BASE_PATH, glob), File::FNM_DOTMATCH)
    .map { File.expand_path(_1).to_s }
    .uniq
end

def parse_tool_version_files(files)
  files.each_with_object(Hash.new { |h, k| h[k] = Set.new }) do |file, result|
    File.new(file).each_line do |line|
      next if line.start_with?(/\s*#/)

      tool, version = line.split.map(&:strip)
      result[tool] << version
    end
  end
end

def tool_versions_files
  uniq_file_paths(".tool-versions") << "#{ENV['HOME']}/.tool-versions"
end

def merge_ruby_version(tool_versions)
  uniq_file_paths(".ruby-version")
    .each_with_object(tool_versions) do |file, result|
      version = File.read(file).chomp

      result["ruby"] << version
    end
end

def clean_up(tool_versions)
  tool_versions.reject { |k, v| k.to_s.empty? || v.to_s.empty? }
end

def uninstall_exceeding(tool_versions)
  tool_versions.each do |tool, versions|
    installed = asdf('list', tool)

    next unless installed.success?

    versions
      .to_a
      .difference(installed.output.split("\n").map(&:strip))
      .each do |version|
        puts "Removing #{tool}@#{version}"
        asdf('uninstall', tool, version)
      end
  end
end

tool_versions_files
  .then(&method(:parse_tool_version_files))
  .then(&method(:merge_ruby_version))
  .then(&method(:clean_up))
  .then(&method(:uninstall_exceeding))

asdf('reshim')
