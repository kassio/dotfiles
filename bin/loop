#!/usr/bin/env bash

function show_help {
  echo -e "usage: loop [OPTIONS] <command>
  command         the command that will be executed
  OPTIONS:
    -h, --help      show this help message
    -f, --failfast  fails as soon as the <command> fails, does not fail fast by default
    -c, --clear     clear the console before the <command> runs, does not clear by default
    -t, --times     how many times <command> will run, -1 means forever, by default -1.
    -w, --wait      how long will wait to run <command> again, does not wait by default
"
}

function report {
  echo -e "
KILLED
running '${cmd}' for the ${build_count} time.
failed ${error_count} times
"
  exit "${error_count}"
}; trap report SIGINT SIGTERM

# options
failfast=${LOOP_FAILFAST:-false}
clear=${LOOP_CLEAR:-false}
times=${LOOP_TIMES:--1}
wait=${LOOP_WAIT:-0}

function parse_args {
  case $1 in
    -h|--help)
      show_help
      exit 0
      ;;
    -f|--failfast)
      shift
      failfast=true

      parse_args "$@"
      ;;
    -c|--clear)
      shift
      clear=true

      parse_args "$@"
      ;;
    -t|--times)
      shift
      times=$1
      shift

      parse_args "$@"
      ;;
    -w|--wait)
      shift
      wait=$1
      shift

      parse_args "$@"
      ;;
    *)
      cmd="$*"
      ;;
  esac
}

function loop-it {
  parse_args "$@"

  cmd=$(echo "${cmd}" | sed "s/'/'\\''/g")

  if [ -z "${cmd}" ]
  then
    show_help
    exit 1
  fi

  build_count=0
  error_count=0
  while [ "${build_count}" -lt "${times}" ] || [ "${times}" -eq -1 ]
  do
    ((++build_count))
    [ ${clear} = true ] && clear

    if eval "${cmd}" 2>/dev/null
    then
      ((++error_count))
      if [[ "${failfast}" = true ]]
      then
        break
      fi
    fi
    [ "${wait}" -gt 0 ] && sleep "${wait}"
  done

  [ "${error_count}" -gt 0 ] && echo "failed: ${error_count} of ${times}"
  exit ${error_count}
}

loop-it "$@"
