#!/usr/bin/env bash

pushd "${PWD}" > /dev/null && trap 'popd &> /dev/null' EXIT HUP INT QUIT TERM

OK=" 👌 "
ERROR=" 🚫 "
SUN=" 🔅 "
ARROW=" ➡️  "

function print() { echo -ne "$1" >&3; }
function sun() { print "${SUN} $1"; }
function log() { print "\t\t $1"; }
function arrow() { log "${ARROW} $1"; }

function status() {
  if [ $? -eq 0 ]
  then
    print " ${OK}\n"
  else
    print " ${ERROR}\n"
  fi
}

function sync() {
  trap 'exit -1' EXIT HUP INT QUIT TERM

  local remote="$1"
  local path="$2"
  local master="$(cat .git/custom-master || echo 'master')"
  local branch="$(git symbolic-ref --short HEAD)"

  function update() {
    sun "Updating ${path}\n"

    if [ "${branch}" != "${master}" ]
    then
      log "» ${branch}"
      fetch_pull

      log "» ${master}"
      git checkout ${master}
      fetch_pull

      git checkout ${branch}
      rebase
    else
      log "» ${master}"
      git checkout ${master}
      fetch_pull
    fi
  }

  function fetch_pull() {
    git fetch --prune --prune-tags --tags --recurse-submodules
    git pull
    status
  }

  function rebase() {
    arrow "Rebasing '${branch}' on '${master}'"
    git rebase ${master}
    status
  }

  function clone() {
    echo "${SUN} Cloning ${remote} to ${path}"
    git clone ${remote} ${path} --recurse-submodules
    status
  }

  if [ -d ${path} ]
  then
    pushd ${path}
    update
    popd
  else
    clone
  fi
}

# Only print when redirecting to &3
exec 3>/dev/stdout
exec 1>/dev/null
exec 2>/dev/null
files=${1:-${REPOS_FILES}}

OIFS=$IFS
IFS=":"
for repos in $(echo ${files})
do
  IFS=$OIFS
  for repo in $(cat ${repos})
  do
    remote=${repo%|*}
    path=$(echo -n ${repo#*|} | sed "s#\$HOME#$HOME#")

    sync ${remote} ${path}
  done
done
