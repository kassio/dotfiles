#!/usr/bin/env bash

pushd "${PWD}" > /dev/null && trap 'popd &> /dev/null' EXIT HUP INT QUIT TERM

OK=" 👌 "
ERROR=" 🚫 "
SUN=" 🔅 "
ARROW=" ➡️  "

# Only print when redirecting to &3
exec 3>/dev/stdout
exec 1>/dev/null

_print() { echo -ne "$1" >&3; }
sun() { _print "${SUN} $1\n"; }
log() { _print "\t\t $1"; }
arrow() { log "${ARROW} $1"; }
errormsg() { _print "\033[31m${ERROR} $1\033[0m"; }

status_for() {
  read -r error < <(eval "$*" 2>&1 1>/dev/null)

  if [ -z "${error}" ]
  then
    _print " ${OK}\n"
    return 0
  else
    errormsg "${error}\n"
    return 1
  fi
}

update() {
  local master
  local current_branch
  local path

  path="$1"

  pushd "${path}"

  master="$(cat .git/custom-master 2> /dev/null || echo 'master')"
  current_branch="$(git symbolic-ref --short HEAD)"

  sun "Updating ${path}"

  for branch in $(git branch --list | cut -c 3-)
  do
    log "» ${branch}"

    git switch "${branch}" 2>/dev/null
    git fetch --prune --prune-tags --tags --recurse-submodules
    (status_for git pull) || break


    if [ "${branch}" == "${current_branch}" ] \
      && [ "${current_branch}" != "${master}" ]
        then
          arrow "Rebasing '${current_branch}' on '${master}'"
          status_for git rebase "${master}"
    fi
  done

  git switch "${current_branch}" 2>/dev/null

  popd
}

clone() {
  remote="$1"
  path="$2"

  sun "Cloning ${remote} to ${path}"
  status_for git clone "${remote}" "${path}" --recurse-submodules
}

sync() {
  trap 'exit 1' EXIT HUP INT QUIT TERM

  local remote="$1"
  local path="$2"

  if [ -d "${path}" ]
  then
    update "${path}"
  else
    clone "${remote}" "${path}"
  fi
}

IFS=':' read -ra files <<< "${1:-${REPOS_FILES}}"
for file in "${files[@]}"
do
  while IFS='|' read -r remote path
  do
    sync "${remote}" "${path//\$HOME/$HOME}"
  done < "${file}"
done
