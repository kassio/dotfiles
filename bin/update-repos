#!/usr/bin/env bash

pushd "${PWD}" > /dev/null && trap 'popd &> /dev/null' EXIT HUP INT QUIT TERM

OK=" 👌 "
ERROR=" 🚫 "
SUN=" 🔅 "
ARROW=" ➡️  "

# Only print when redirecting to &3
exec 3>/dev/stdout
exec 1>/dev/null

function _print() { echo -ne "$1" >&3; }
function sun() { _print "${SUN} $1\n"; }
function log() { _print "\t\t $1"; }
function arrow() { log "${ARROW} $1"; }
function errormsg() { _print "\033[31m${ERROR} $1\033[0m"; }

function status_for() {
  read -r error < <(eval "$*" 2>&1 1>/dev/null)

  if [ -z "${error}" ]
  then
    _print " ${OK}\n"
    return 0
  else
    errormsg "${error}\n"
    return 1
  fi
}

function sync() {
  trap 'exit 1' EXIT HUP INT QUIT TERM

  local remote="$1"
  local path="$2"

  function update() {
    pushd "${path}"

    local master="$(cat .git/custom-master 2> /dev/null || echo 'master')"
    local current_branch="$(git symbolic-ref --short HEAD)"

    sun "Updating ${path}"

    for branch in $(git branch --list | cut -c 3-)
    do
      log "» ${branch}"

      git switch "${branch}" 2>/dev/null
      git fetch --prune --prune-tags --tags --recurse-submodules
      (status_for git pull) || break


      if [ "${branch}" == "${current_branch}" ] \
        && [ "${current_branch}" != "${master}" ]
      then
        arrow "Rebasing '${current_branch}' on '${master}'"
        status_for git rebase "${master}"
      fi
    done

    git switch "${current_branch}" 2>/dev/null

    popd
  }

function clone() {
  sun "Cloning ${remote} to ${path}"
  status_for git clone "${remote}" "${path}" --recurse-submodules
}

if [ -d "${path}" ]
then
  update
else
  clone
fi
}

IFS=':' read -ra files <<< "${1:-${REPOS_FILES}}"
for file in "${files[@]}"
do
  while IFS='|' read -r remote path
  do
    sync "${remote}" "${path//\$HOME/$HOME}"
  done < "${file}"
done
