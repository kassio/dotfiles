#!/usr/bin/env ruby
# frozen_string_literal: true

require 'open3'

class Repositories
  include ::Enumerable

  Repository = Struct.new(:remote, :path) do
    def exists?
      Dir.exist?(path)
    end
  end

  def self.each(&block)
    new.each(&block)
  end

  def self.current
    new.current
  end

  def initialize
    @files = Array(ENV['REPOS_FILES'].split(':')).flatten
  end

  def each(&block)
    repositories.each(&block)
  end

  def current
    map do |repository|
      String.format(
        '%<remote>s %<path>s',
        remote: repository.remote.ljust(longest_remote_name),
        path: repository.path
      )
    end.join("\n")
  end

  private

  def longest_remote_name
    @longest_remote_name ||= repositories.map { |repo| repo.remote.length }.max
  end

  def repositories
    @repositories ||= @files.flat_map do |file|
      File.new(file).readlines.map do |line|
        remote, path = line.split('|').map(&:to_s).map(&:strip)

        next if remote == ''

        Repository.new(remote.strip, format_path(path))
      end.compact
    end
  end

  def format_path(path)
    path.gsub(/\$(?<varname>[A-Z_]+)\b/) do
      name = Regexp.last_match(:varname)
      ENV[name] || raise(NameError, "Unknown environment variable '$#{name}'")
    end
  end
end

class Updater
  def self.sync(user_options)
    Repositories.each do |repository|
      if repository.exists?
        new(repository, user_options).update
      else
        new(repository, user_options).clone
      end
    end
  end

  def initialize(repository, user_options)
    @repository = repository
    @user_options = user_options
    @git = Git.new(repository)
  end

  def update
    Printer.puts repository.path, prefix: :update

    former_branch = git.branch
    branches = git.branches
    main_branch = branches.delete(git.main_branch)
    main_branch_updated = main_branch && update_branch(main_branch)
    all_branches_updated = update_branches(branches)
    clean(main_branch_updated && all_branches_updated)
  ensure
    git.switch(former_branch) if former_branch
  end

  def clone
    Printer.puts repository.path, prefix: :update
    Printer.print "cloning #{repository.remote} ", prefix: :download, indent: 2

    with_report { git.clone }
  end

  private

  attr_reader :repository, :user_options, :git

  def update_branches(branches)
    branches.filter_map do |branch|
      if git.remote_for(branch).start_with?('origin')
        update_branch(branch)
      end
    end.all?(&:success?)
  end

  def update_branch(branch)
    Printer.print "updating #{branch} ", prefix: :arrow, indent: 2

    git.switch branch
    git.fetch

    _, _, status = with_report { git.pull }

    status
  end

  def with_report
    result = yield
    _, stderr, status = result

    if status.success?
      Printer.puts symbol: :ok
    else
      Printer.puts symbol: :error
      stderr.to_s.split("\n").each do |err|
        Printer.puts err, indent: 2, color: :error
      end
    end

    result
  end

  def clean(condition)
    if user_clean_option? && condition
      Printer.puts "cleaning", prefix: :cleaning, indent: 2
      git.clean
    end
  end

  def user_clean_option?
    !user_options.include?('--no-clean')
  end
end

class Generator
  def self.list
    new.list
  end

  def initialize
    @git = Git.new
  end

  def list
    Dir.each_child(Dir.pwd).map do |entry|
      next unless File.directory?(entry)

      Dir.chdir(entry) do
        "#{remote}|#{expanded_path(entry)}" unless remote.empty?
      end
    end.compact.join("\n")
  end

  private

  def remote
    @remote ||=
      if Dir.exist?('.git')
        @git.remote.slice(0).chomp.strip
      end.to_s
  end

  def expanded_path(entry)
    File.expand_path(entry).sub(ENV['HOME'], '$HOME')
  end
end

class Git
  def initialize(repository = nil)
    @repository = repository
  end

  def clone
    git 'clone', repository.remote, repository.path, chdir: false
  end

  def branch
    git('symbolic-ref', '--short', 'HEAD')
      .slice(0)
      .split("\n")
      .first
  end

  def main_branch
    git('rev-parse', '--verify', 'origin/main')
      .slice(0)
      .then { |rev| rev.empty? ? 'master' : 'main' }
  end

  def branches
    git('branch', '--list')
      .slice(0)
      .split("\n")
      .map { |branch| branch.delete('*').strip }
  end

  def switch(branch)
    git 'switch', branch
  end

  def remote
    git 'remote', 'get-url', '--push', 'origin', chdir: false
  end

  def remote_for(ref)
    git('rev-parse', '--abbrev-ref', "#{ref}@{upstream}")
      .slice(0)
      .split("\n")
      .first
      .to_s
  end

  def fetch
    git 'fetch', '--prune', '--prune-tags', '--tags', '--recurse-submodules'
  end

  def pull
    git 'pull', '--quiet'
  end

  def clean
    git 'gc'
    git 'prune'
  end

  private

  attr_reader :repository

  FakeStatus = Struct.new(:success?)

  def git(*args, chdir: true)
    cmd = ['git', args].flatten

    if chdir
      Dir.chdir(repository&.path) do
        Open3.capture3(*cmd)
      end
    else
      Open3.capture3(*cmd)
    end
  rescue StandardError => e
    [nil, e.message, FakeStatus.new(false)]
  end
end

class Printer
  COLORS = {
    ok: 34,
    error: 160,
    arrow: 33,
    cleaning: 207,
    update: 33,
    download: 33
  }.freeze

  SYMBOLS = {
    ok: "✓",
    error: "✗",
    arrow: "»",
    cleaning: "※",
    update: "⟳ ",
    download: "↓"
  }.freeze

  class << self
    # rubocop: disable Metrics/ParameterLists
    # rubocop: disable Metrics/CyclomaticComplexity
    def print(
      text = '',
      symbol: nil,
      prefix: nil,
      indent: 0,
      color: nil,
      break_line: false
    )
      color ||= color&.to_sym
      prefix ||= symbol&.to_sym
      prefix ||= prefix&.to_sym

      Kernel.print(
        text
        .then { prefixify(_1, prefix) }
        .then { break_line ? "#{_1}\n" : _1 }
        .then { colorify(_1, color) }
        .then { "#{'  ' * indent}#{_1}" }
      )
    end
    # rubocop: enable Metrics/ParameterLists
    # rubocop: enable Metrics/CyclomaticComplexity

    def puts(text = '', symbol: nil, prefix: nil, indent: 0, color: nil)
      print(
        text,
        symbol: symbol,
        prefix: prefix,
        indent: indent,
        color: color,
        break_line: true
      )
    end

    private

    def colorify(msg, sym)
      return msg unless COLORS.key?(sym)

      "\e[38;5;#{COLORS[sym]}m#{msg}\e[00m"
    end

    def prefixify(msg, sym)
      return msg unless SYMBOLS.key?(sym)

      "#{colorify(SYMBOLS[sym], sym)} #{msg}"
    end
  end
end

case ARGV[0]
when /\A(-c|--current)\Z/
  puts Repositories.current
when /\A(-g|--generate)\Z/
  puts Generator.list
when /\A(-h|--help)\Z/
  puts <<~HELP
    USAGE: repos [--update|--current|--generate|--help]

    Manage (clone, sync, list) git repositories based on the list of repositories
    defined in `$REPOS_FILES`.

    `$REPOS_FILES` must contain a list of files separated by ":"

    A Reposfile must contain a list of Repositories to sync, each line of the file
    must follow the format: "<git remote url>|<destination folder>". For example:

        https://github.com/rails/rails|~/src/rails
        https://github.com/kassio/neoterm|$HOME/.config/nvim/packed/neoterm

    Options:
      --update   | -u updates all the repositories. (default)
                      Only branchs with "origin" remote will be synced
      --current  | -c list the repositories currently registered in `$REPOS_FILES`
      --generate | -g list the repositories from the current directory in the Reposfile format.
                      Useful to generate a Reposfile, like: `repos -g > Reposfile`
  HELP
else
  Updater.sync(ARGV)
end
