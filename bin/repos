#!/usr/bin/env bash

pushd "${PWD}" > /dev/null &&
  trap 'popd &> /dev/null' EXIT HUP INT QUIT TERM

OK=" 👌 "
ERROR=" 🚫 "
ARROW=" »"
CLEANING=" 🧹 "
UPDATE_ARROW=" 🔄 "
DOWNLOAD_ARROW=" ⬇️  "

# Only print when redirecting to &3
exec 3> /dev/stdout
exec 4> /dev/stderr
exec 1> /dev/null
exec 2> /dev/null

_print() { echo -ne "$1" >&3; }
_println() { echo -ne "$1\n" >&3; }
_printerr() { echo -ne "$1" >&4; }
log() { _print "\t\t $1"; }
errormsg() { _printerr "\033[31m${ERROR}\n\t\t\t $1\033[0m"; }

status_for() {
  read -r error < <(eval "$*" 2>&1 1> /dev/null)

  if [ -z "${error}" ]; then
    _print "${OK}\n"
    return 0
  else
    errormsg "${error}\n"
    return 1
  fi
}

update_branch() {
  local branch="$1"
  _print "\t\t${ARROW} ${branch}"

  git switch "${branch}" 2> /dev/null
  git fetch --prune --prune-tags --tags --recurse-submodules

  (status_for git pull --quiet)
}

clean_and_prune() {
  _println "\t\t${CLEANING} cleaning"
  git gc && git prune
}

sync() {
  local current_branch
  local path

  path="$1"

  pushd "${path}" || _printerr "${path} not found"

  update_branch "master"

  current_branch="$(git symbolic-ref --short HEAD)"

  for branch in $(git branch --list | cut -c 3- | grep -v "master"); do
    branch_remote="$(git rev-parse --abbrev-ref "${branch}@{upstream}" 2> /dev/null | cut -d '/' -f1)"
    if [ "${branch_remote}" = "origin" ]; then
      update_branch "${branch}"
    fi
  done

  git switch "${current_branch}" 2> /dev/null

  clean_and_prune

  popd || exit 1
}

clone() {
  remote="$1"
  path="$2"

  status_for git clone "${remote}" "${path}" --recurse-submodules
}

_update() {
  local files
  local path=""
  trap 'exit 1' EXIT HUP INT QUIT TERM

  IFS=':' read -ra files <<< "${1:-${REPOS_FILES}}"
  for file in "${files[@]}"; do
    while IFS='|' read -r remote path; do
      [ "${remote}" == "" ] && continue

      path="${path//\$HOME/$HOME}"

      if [ -d "${path}" ]; then
        _println "${UPDATE_ARROW} ${path}"
        sync "${path}"
      else
        _println "${DOWNLOAD_ARROW} ${path}"
        clone "${remote}" "${path}"
      fi
    done < "${file}"
  done
}

_list() {
  pushd "$1" > /dev/null &&
    trap 'popd > /dev/null' EXIT HUP INT QUIT TERM

  find "${PWD}" -mindepth 1 -maxdepth 1 -type d |
    sort -u |
    while IFS= read -r repo; do
      if [ -d "${repo}/.git" ]; then
        cd "${repo}" &> /dev/null || exit 1
        target="${PWD%% }"
        remote="$(git remote get-url --push origin)"

        if [ -n "$remote" ]; then
          _println "${remote}|${target/${HOME}/\$HOME}"
        fi

        cd - &> /dev/null || exit 1
      fi
    done
}

_current() {
  IFS=':' read -ra files <<< "${1:-${REPOS_FILES}}"
  for file in "${files[@]}"; do
    column -t -s'|' "${file}" >&3
  done
}

_help() {
  _println "Manage (clone, sync, list) git repositories

USAGE: repos [--list path|--update|--current]
Options:
\t--update    | -u \tupdates the list of repositories on \$REPOS_FILES
\t                 \tBranchs with remote set to \"origin\" will be synced
\t  --list    | -l \tlist the repositories on the given path
\t  --current | -c \tlist the repositories registered in \$REPOS_FILES

\`\$REPOS_FILES\` must contain a list of files separated by \`:\`
A Reposfile must contain a list of repos to sync, each line should follow the format:
  \`<git remote url>|<destination folder>\`"
}

case "$1" in
  --update | -u)
    shift
    _update "$@"
    ;;
  --list | -l)
    shift
    _list "$@"
    ;;
  --current | -c)
    shift
    _current "$@"
    ;;
  *)
    _help
    ;;
esac
